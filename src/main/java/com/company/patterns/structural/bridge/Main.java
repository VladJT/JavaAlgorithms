package com.company.patterns.structural.bridge;

/**
 * <h1>Мост (Bridge)</h1>
 * <h2><font color="#fa8e47">Сложность:⭐⭐⭐</font><br>
 * <font color="#fa8e47">Популярность:⭐</font>⭐⭐<p></h2>
 * структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий,
 * которые потом можно развивать отдельно друг от друга.<br>
 * Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу.
 * Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.
 * <p>
 * <font color="#fa8e47">Применимость:<br></font>
 * Паттерн Мост особенно полезен когда вам приходится делать кросс-платформенные приложения,
 * поддерживать несколько типов баз данных или работать с разными поставщиками похожего API (например, cloud-сервисы, социальные сети и т. д.)
 * <p>
 * <font color="#fa8e47">Признаки применения паттерна:<br></font>
 * Если в программе чётко выделены классы «управления» и несколько видов классов «платформ»,
 * причём управляющие объекты делегируют выполнение платформам, то можно сказать, что у вас используется Мост.
 * <p>
 * <font color="#fa8e47">Где используют паттерн Bridge<br></font>
 * <ul>
 * <li>Если необходимо расширить количество сущностей в две стороны (геометрические фигуры, цвета).</li>
 * <li>Если есть желание разделить большой класс, который не отвечает принципу Single responsibility, на более маленькие классы с узкопрофильным функционалом.</li>
 * <li>При возможной необходимости вносить изменения в логику работы неких сущностей во время работы программы.</li>
 * <li>При необходимости спрятать реализацию от клиентов класса (библиотеки).</li></ul>
 * При использовании паттерна каждый раз нужно помнить, что он добавляет дополнительные сущности в код — не совсем логично применять его в проекте, где всего одна геометрическая фигура и один-два возможных ее цвета.
 * <p>
 * <font color="#fa8e47">Преимущества Bridge:<br></font>
 * <ul>
 * <li>Улучшает масштабируемость кода — можно добавлять функционал, не боясь сломать что-то в другой части программы.</li>
 * <li>Уменьшает количество подклассов — работает при необходимости расширения количества сущностей в две стороны (например, количество фигур и количество цветов).</li>
 * <li>Дает возможность отдельно работать над двумя самостоятельными ветками Абстракции и Реализации — это могут делать два разных разработчика, не вникая в детали кода друг друга.</li>
 * <li>Уменьшение связанности классов — единственное место связки двух классов — это мост (поле Color color).</li></ul>
 * <font color="#fa8e47">Недостатки Bridge:<br></font>
 * <ul>
 * <li>В зависимости от конкретной ситуации и структуры проекта в целом, возможно негативное влияние на продуктивность программы
 * (например, если нужно инициализировать большее количество объектов).</li>
 * <li>Усложняет читаемость кода из-за необходимости навигации между классами.</li></ul>
 *
 * <font color="fa8eff">Паттерн Bridge часто путают с другим шаблоном проектирования — Strategy. Они оба используют композицию (в примере с фигурами и цветами мы использовали агрегацию,
 * но паттерн Bridge может использовать и композицию), делегируя работу другим объектам.
 * Но разница между ними есть, и она огромная.<br>Паттерн Strategy является поведенческим паттерном: он решает совсем другие задачи.
 * Strategy обеспечивает взаимозаменяемость алгоритмов, в то время как Bridge отделяет абстракцию от реализации, чтобы обеспечить возможность выбора между различными имплементациями.
 * То есть, Bridge, в отличие от Strategy, применяется к целым конструкциям или иерархическим структурам.</font>
 */


// У нас есть абстрактный класс Shape, который обобщенно описывает геометрическую фигуру
// Класс Shape представляет собой Абстракцию — механизм управления раскраской фигур в различные цвета, который делегирует Реализацию интерфейсу Color.
abstract class Shape {
    protected Color color;//Поле Color color и является мостом (bridge), который взаимосвязывает две отдельные иерархии классов.

    public Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}

//Когда мы решим добавить фигуры треугольника и прямоугольника, мы унаследуемся от класса Shape
// Классы Triangle, Rectangle являются реальными объектами, которые используют механизм, предложенный классом Shape.
class Rectangle extends Shape {
    public Rectangle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("Drawing rectangle");
        color.fillColor();
    }
}

class Triangle extends Shape {
    public Triangle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("Drawing triangle");
        color.fillColor();
    }
}

/*
У каждой фигуры будет свой цвет, от которого будет зависеть функционал метода draw().
Чтобы иметь различные реализации метода draw(), нам необходимо создать класс для каждой фигуры, соответствующий цвету.
Если три цвета, то шесть классов: TriangleBlack, TriangleGreen, TriangleRed, RectangleBlack, RectangleGreen и RectangleRed.
Шесть классов — не такая уж и большая проблема. Но! Если нам нужно будет добавить новую фигуру или цвет, количество классов будет расти в геометрической прогрессии.
Как выйти из сложившейся ситуации? Хранение цвета в поле и перебор вариантов через условные конструкции — не лучший выход.
Хорошее решение — вывести цвет в отдельный интерфейс.
 */
interface Color {
    void fillColor();
}

class BlackColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in black color");
    }
}

class GreenColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in green color");
    }
}

class RedColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in red color");
    }
}


class Main {
    public static void main(String[] args) {
        Shape[] shapes = {new Rectangle(new BlackColor()), new Triangle(new RedColor())};
        shapes[0].draw();
        shapes[1].draw();
    }

}
